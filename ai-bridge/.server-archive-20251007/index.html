
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-AI Bridge v2.1 - Enhanced</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; background-color: #f4f4f9; }
        h1 { text-align: center; color: #333; margin: 0.5em; font-size: 1.5em; }
        .subtitle { text-align: center; color: #666; margin: -0.5em 0 1em 0; font-size: 0.9em; }

        /* Single unified view layout */
        .main-content { display: flex; flex: 1; overflow: hidden; }
        .messages-panel { flex: 1; overflow-y: auto; padding: 1em; }

        /* Message styles */
        .message { border: 1px solid #ccc; padding: 1em; margin-bottom: 1em; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); position: relative; }
        .message.claude { background-color: #eef8ff; border-left: 4px solid #0066cc; }
        .message.gemini { background-color: #fff5f8; border-left: 4px solid #cc0066; }
        .message.user { background-color: #f0f0f0; border-left: 4px solid #666; }
        .message.pending { background-color: #fffbe6; border-left: 4px solid #ffa500; }
        .message.rejected { background-color: #ffebee; border-left: 4px solid #ef4444; opacity: 0.7; }
        .message-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5em; }
        h3 { margin: 0; font-size: 0.9em; color: #555; }
        .timestamp { font-size: 0.75em; color: #999; }
        pre { white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; color: #333; margin: 0.5em 0 0 0; }
        .summary { font-style: italic; color: #666; margin-top: 0.5em; padding: 0.5em; background: rgba(255,255,255,0.5); border-radius: 4px; font-size: 0.85em; }

        /* Action buttons inline */
        .message-actions { margin-top: 1em; padding-top: 1em; border-top: 1px solid #ddd; display: flex; gap: 0.5em; align-items: center; }
        .message-actions textarea { flex: 1; min-height: 40px; padding: 0.5em; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; }
        .message-actions button { padding: 0.5em 1em; white-space: nowrap; }

        /* Review panel */
        .review-header { font-weight: bold; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 2px solid #ddd; }
        .pending-message { background: #fffbe6; padding: 1em; border-radius: 8px; margin-bottom: 1em; border: 1px solid #ffa500; }
        .pending-message h4 { margin: 0 0 0.5em 0; color: #d97706; }
        .pending-content { background: white; padding: 0.75em; border-radius: 4px; margin: 0.5em 0; max-height: 150px; overflow-y: auto; font-size: 0.85em; }

        /* Comment box */
        .comment-section { margin: 1em 0; }
        .comment-section label { display: block; margin-bottom: 0.5em; font-weight: 500; }
        .comment-section textarea { width: 100%; min-height: 80px; padding: 0.5em; border: 1px solid #ddd; border-radius: 4px; font-family: inherit; resize: vertical; }

        /* Action buttons */
        .actions { display: flex; gap: 0.5em; margin-top: 1em; }
        button { padding: 0.5em 1em; cursor: pointer; border: none; border-radius: 4px; font-weight: 500; transition: all 0.2s; }
        button.approve { background: #10b981; color: white; flex: 1; }
        button.approve:hover { background: #059669; }
        button.reject { background: #ef4444; color: white; flex: 1; }
        button.reject:hover { background: #dc2626; }
        button.neutral { background: #6b7280; color: white; }
        button.neutral:hover { background: #4b5563; }

        /* Controls */
        .controls { padding: 1em; border-top: 1px solid #ddd; background: #fff; display: flex; justify-content: space-between; align-items: center; }
        .controls-left { display: flex; gap: 0.5em; align-items: center; }
        .controls-right { font-size: 0.85em; color: #666; }

        /* Filter badges */
        .filter-badge { display: inline-block; padding: 0.25em 0.5em; margin-left: 0.5em; border-radius: 12px; font-size: 0.75em; font-weight: bold; }
        .filter-badge.pending { background: #ffa500; color: white; }
        .filter-badge.all { background: #6b7280; color: white; }

        /* Empty state */
        .empty-state { text-align: center; padding: 2em; color: #999; }
    </style>
</head>
<body>
    <h1>AI-AI Communication Bridge v2.1 <span class="subtitle">Enhanced Message Review</span></h1>

    <div class="main-content">
        <!-- Unified Messages Panel -->
        <div class="messages-panel">
            <div class="controls">
                <div class="controls-left">
                    <button class="neutral" onclick="toggleFilter()">
                        Filter: <span id="filterMode">All</span>
                    </button>
                    <button class="neutral" onclick="clearContext()">Clear Context</button>
                </div>
                <div class="controls-right" id="contextInfo">Loading...</div>
            </div>
            <div id="messages"></div>
        </div>
    </div>

    <script>
        const messagesDiv = document.getElementById('messages');
        const contextInfo = document.getElementById('contextInfo');
        const filterModeSpan = document.getElementById('filterMode');

        let allMessages = [];
        let filterMode = 'all'; // 'all' or 'pending'

        async function fetchMessages() {
            try {
                const response = await fetch('/messages');
                allMessages = await response.json();
                renderMessages();
            } catch (e) {
                console.error("Failed to fetch messages", e);
            }
        }

        function renderMessages() {
            const messagesToShow = filterMode === 'pending'
                ? allMessages.filter(m => m.status === 'pending')
                : allMessages;

            // Save current textarea values and focus before re-render
            const textareaValues = {};
            let focusedTextareaId = null;
            let cursorPosition = 0;
            document.querySelectorAll('textarea[id^="comment-"]').forEach(ta => {
                if (ta.value) textareaValues[ta.id] = ta.value;
                if (document.activeElement === ta) {
                    focusedTextareaId = ta.id;
                    cursorPosition = ta.selectionStart;
                }
            });

            messagesDiv.innerHTML = '';

            if (messagesToShow.length === 0) {
                messagesDiv.innerHTML = '<div class="empty-state">No messages to display</div>';
                return;
            }

            // Reverse to show newest first
            const sortedMessages = [...messagesToShow].reverse();

            for (const msg of sortedMessages) {
                const div = document.createElement('div');
                const isPending = msg.status === 'pending';
                const isRejected = msg.status === 'rejected';
                div.className = 'message ' + msg.from + (isPending ? ' pending' : '') + (isRejected ? ' rejected' : '');

                const timestamp = msg.file.match(/\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/)?.[0] || 'Unknown';
                const summary = generateSummary(msg.content);

                const statusBadge = isPending ? '<span class="filter-badge pending">PENDING</span>' :
                                   isRejected ? '<span class="filter-badge" style="background:#ef4444;">REJECTED</span>' :
                                   '<span class="filter-badge" style="background:#10b981;">APPROVED</span>';

                div.innerHTML = `
                    <div class="message-header">
                        <h3>From: ${msg.from} ${statusBadge}</h3>
                        <span class="timestamp">${timestamp}</span>
                    </div>
                    <pre>${msg.content}</pre>
                    ${msg.comment ? '<div class="summary" style="background:#e3f2fd;">üí¨ Comment: ' + msg.comment + '</div>' : ''}
                    ${isPending ?
                        '<div class="message-actions">' +
                            '<textarea id="comment-' + msg.file + '" placeholder="Add comment (optional)..."></textarea>' +
                            '<button class="neutral" onclick="markAsRead(\'' + msg.file + '\')">üëÅÔ∏è Read</button>' +
                            '<button class="approve" onclick="approveMessage(\'' + msg.file + '\')">‚úì Approve</button>' +
                            '<button class="reject" onclick="rejectMessage(\'' + msg.file + '\')">‚úó Reject</button>' +
                        '</div>'
                    : ''}
                `;
                messagesDiv.appendChild(div);
            }

            // Restore textarea values and focus after re-render
            Object.keys(textareaValues).forEach(id => {
                const ta = document.getElementById(id);
                if (ta) ta.value = textareaValues[id];
            });

            // Restore focus and cursor position
            if (focusedTextareaId) {
                const ta = document.getElementById(focusedTextareaId);
                if (ta) {
                    ta.focus();
                    ta.setSelectionRange(cursorPosition, cursorPosition);
                }
            }

            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function generateSummary(content) {
            // Simple summary: first sentence or first 100 chars
            const firstLine = content.split('\n')[0];
            if (firstLine.length > 100) {
                return firstLine.substring(0, 97) + '...';
            }
            return firstLine || 'Message content';
        }

        function toggleFilter() {
            filterMode = filterMode === 'all' ? 'pending' : 'all';
            filterModeSpan.textContent = filterMode === 'all' ? 'All' : 'Pending Only';
            renderMessages();
        }

        async function approveMessage(file) {
            const comment = document.getElementById('comment-' + file)?.value || '';
            try {
                const response = await fetch('/message/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file, comment })
                });
                const result = await response.json();
                if (response.ok) {
                    alert(`Message approved!${comment ? '\nYour comment: ' + comment : ''}`);
                    fetchMessages();
                } else {
                    alert('Error approving message: ' + result.error);
                }
            } catch (e) {
                console.error('Failed to approve message', e);
                alert('Failed to approve message');
            }
        }

        async function rejectMessage(file) {
            const comment = document.getElementById('comment-' + file)?.value || '';
            if (confirm('Reject this message?')) {
                try {
                    const response = await fetch('/message/reject', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ file, comment })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        alert(`Message rejected!${comment ? '\nYour comment: ' + comment : ''}`);
                        fetchMessages();
                    } else {
                        alert('Error rejecting message: ' + result.error);
                    }
                } catch (e) {
                    console.error('Failed to reject message', e);
                    alert('Failed to reject message');
                }
            }
        }

        async function markAsRead(file) {
            try {
                const response = await fetch('/message/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file, comment: 'Read' })
                });
                const result = await response.json();
                if (response.ok) {
                    fetchMessages(); // Refresh without alert
                } else {
                    alert('Error marking as read: ' + result.error);
                }
            } catch (e) {
                console.error('Failed to mark as read', e);
                alert('Failed to mark as read');
            }
        }

        async function fetchContext() {
            try {
                const response = await fetch('/context');
                const data = await response.json();
                contextInfo.textContent = `${data.count} messages in context`;
            } catch (e) {
                console.error("Failed to fetch context", e);
            }
        }

        async function clearContext() {
            if (confirm('Clear conversation context?')) {
                try {
                    await fetch('/context/clear', { method: 'POST' });
                    alert('Context cleared!');
                    fetchContext();
                } catch (e) {
                    console.error("Failed to clear context", e);
                }
            }
        }

        setInterval(fetchMessages, 2000);
        setInterval(fetchContext, 5000);
        fetchMessages();
        fetchContext();
    </script>
</body>
</html>
    