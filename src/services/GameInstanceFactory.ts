// src/services/GameInstanceFactory.ts

import { IServiceContainer } from '../types/ServiceContracts';
import { DataService } from './DataService';
import { StateService } from './StateService';
import { LoggingService } from './LoggingService';
import { TurnService } from './TurnService';
import { CardService } from './CardService';
import { PlayerActionService } from './PlayerActionService';
import { MovementService } from './MovementService';
import { GameRulesService } from './GameRulesService';
import { ResourceService } from './ResourceService';
import { ChoiceService } from './ChoiceService';
import { EffectEngineService } from './EffectEngineService';
import { NegotiationService } from './NegotiationService';
import { TargetingService } from './TargetingService';
import { NotificationService } from './NotificationService';

/**
 * Factory for creating isolated game instances with their own service containers.
 * Each game gets its own set of service instances to prevent state contamination.
 *
 * Used for multi-game server architecture where multiple concurrent games run on one server.
 */
export class GameInstanceFactory {
  /**
   * Create a complete, isolated service container for a single game instance
   *
   * @param gameId - Unique identifier for this game (generated by server or provided)
   * @returns A service container with all game services initialized and wired together
   */
  createGameInstance(gameId: string): IServiceContainer {
    // Instantiate services - Phase 1 & 2: Core services implemented
    const dataService = new DataService();
    const stateService = new StateService(dataService, gameId); // Pass gameId to StateService
    const loggingService = new LoggingService(stateService);
    const resourceService = new ResourceService(stateService);
    const choiceService = new ChoiceService(stateService);
    const gameRulesService = new GameRulesService(dataService, stateService);

    // Wire up circular dependency: StateService needs GameRulesService for condition evaluation
    stateService.setGameRulesService(gameRulesService);

    const cardService = new CardService(dataService, stateService, resourceService, loggingService, gameRulesService);
    const movementService = new MovementService(dataService, stateService, choiceService, loggingService, gameRulesService);
    const targetingService = new TargetingService(stateService, choiceService);

    // Create NotificationService early for TurnService dependency
    const notificationService = new NotificationService(stateService, loggingService);

    // Create temporary services for circular dependency resolution
    const tempEffectEngine = new EffectEngineService(resourceService, cardService, choiceService, stateService, movementService, undefined as any, undefined as any, targetingService, loggingService);
    const negotiationService = new NegotiationService(stateService, tempEffectEngine);

    // Create TurnService with NegotiationService and NotificationService dependencies
    const turnService = new TurnService(dataService, stateService, gameRulesService, cardService, resourceService, movementService, negotiationService, loggingService, choiceService, notificationService);

    // Create final EffectEngineService with TurnService dependency
    const effectEngineService = new EffectEngineService(resourceService, cardService, choiceService, stateService, movementService, turnService, gameRulesService, targetingService, loggingService);

    // Set final EffectEngineService on TurnService and CardService to complete the circular dependencies
    turnService.setEffectEngineService(effectEngineService);
    cardService.setEffectEngineService(effectEngineService);

    const playerActionService = new PlayerActionService(dataService, stateService, gameRulesService, movementService, turnService, effectEngineService, loggingService);

    const services: IServiceContainer = {
      dataService,
      stateService,
      loggingService,
      notificationService,
      turnService,
      cardService,
      playerActionService,
      movementService,
      gameRulesService,
      resourceService,
      choiceService,
      effectEngineService,
      negotiationService,
    };

    return services;
  }

  /**
   * Create a game instance with a generated game ID
   * Useful for quick creation without pre-generating IDs
   *
   * @returns A tuple of [gameId, serviceContainer]
   */
  createGameInstanceWithId(): [string, IServiceContainer] {
    const gameId = this.generateGameId();
    const services = this.createGameInstance(gameId);
    return [gameId, services];
  }

  /**
   * Generate a unique game ID using timestamp and random string
   * Format: game_<timestamp>_<random>
   */
  private generateGameId(): string {
    return `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
